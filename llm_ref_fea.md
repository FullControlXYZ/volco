# VOLCO FEA Module - LLM Reference Document

This document provides a comprehensive overview of the Finite Element Analysis (FEA) module structure and functionality within the VOLCO repository. It serves as a reference for large language models to understand the FEA module without requiring all files to be uploaded as context.

## 1. Module Overview

The FEA module extends VOLCO's capabilities by providing structural analysis functionality for voxel models generated by VOLCO simulations. It enables users to:

- Convert voxel matrices to finite element meshes
- Apply boundary conditions to the mesh
- Solve linear static structural problems
- Visualize results including displacements and stresses using Plotly
- Save and load analysis results in various formats

The module is designed to work seamlessly with VOLCO's voxel-based output, allowing for direct structural analysis of 3D printed parts simulated by VOLCO.

## 2. Module Structure

```
app/postprocessing/fea/
├── __init__.py       # Module entry point
├── core.py           # Main analysis functionality
├── mesh.py           # Mesh generation from voxel matrices
├── boundary.py       # Boundary condition application
├── solver.py         # Linear static FEA solver
├── viz.py            # Visualization of results
└── io.py             # Input/output functionality for saving/loading results
```

## 3. Core Components

### Main Entry Point (app/postprocessing/fea/__init__.py)
- Exposes the main functions: `analyze_voxel_matrix` and `load_fea_results`
- Provides a clean interface for users to access the module's functionality

### Core Analysis (app/postprocessing/fea/core.py)
- `analyze_voxel_matrix()`: Main entry point for FEA analysis
- `load_fea_results()`: Function to load previously saved results
- Orchestrates the entire analysis process from mesh generation to results visualization

### Mesh Generation (app/postprocessing/fea/mesh.py)
- `generate_mesh()`: Converts voxel matrix to hexahedral elements
- `check_continuity()`: Ensures the voxel model represents a single continuous body
- `extract_surface_elements()`: Identifies elements on the model surface
- `get_top_surface_nodes()`, `get_bottom_surface_nodes()`: Helper functions for boundary condition application

### Boundary Conditions (app/postprocessing/fea/boundary.py)
- `apply_default_boundary_conditions()`: Applies standard boundary conditions (fixed bottom, displaced top)
- `apply_custom_boundary_conditions()`: Allows for user-defined boundary conditions
- `create_fixed_support()`, `create_displacement_bc()`, `create_force_bc()`: Helper functions for creating specific boundary conditions
- `select_nodes_by_position()`: Utility to select nodes based on spatial coordinates

### Solver (app/postprocessing/fea/solver.py)
- `solve_static_problem()`: Main solver function for linear static analysis
- `assemble_system()`: Assembles global stiffness matrix and force vector
- `calculate_element_stiffness()`: Computes element stiffness matrices
- `shape_functions()`: Calculates shape functions for hexahedral elements
- `apply_boundary_conditions()`: Modifies system equations to account for boundary conditions
- `solve_system()`: Solves the system of equations
- `calculate_stresses_and_strains()`: Post-processes results to obtain stresses and strains

### Visualization (app/postprocessing/fea/viz.py)
- `visualize_fea()`: Unified visualization function using Plotly with optimized mesh rendering
- `export_visualization()`: Saves visualizations to HTML files
- `visualize_voxel_matrix()`: Visualizes the original voxel matrix

### Input/Output (app/postprocessing/fea/io.py)
- `save_results()`: Saves analysis results to file in various formats
- `load_results()`: Loads analysis results from file
- Support for multiple file formats: pickle, JSON, and HDF5 (if available)

## 4. Key Data Flows

### Voxel Matrix to FE Mesh
1. `analyze_voxel_matrix()` → Entry point for analysis
2. `check_continuity()` → Ensures model is a single body
3. `generate_mesh()` → Converts voxels to hexahedral elements
   - Creates nodes at voxel corners
   - Defines element connectivity
   - Maps physical coordinates based on voxel size

### Boundary Condition Application
1. `apply_default_boundary_conditions()` → Applies standard BCs
   - Bottom surface: Fixed (all DOFs constrained)
   - Top surface: Prescribed displacement (typically 1% of model height)
2. `get_top_surface_nodes()`, `get_bottom_surface_nodes()` → Identify nodes for BC application
3. Creates dictionary mapping node indices to prescribed displacements

### Solving the FE Problem
1. `solve_static_problem()` → Main solver function
2. `assemble_system()` → Creates global stiffness matrix and force vector
3. `apply_boundary_conditions()` → Modifies system for boundary conditions
4. `solve_system()` → Solves the linear system of equations
5. `calculate_stresses_and_strains()` → Post-processes results

### Results Visualization
1. `visualize_fea()` → Creates Plotly visualization with optimized mesh rendering
   - Uses the "volco mesh visualization method" that only renders visible faces
   - Supports showing both original and deformed meshes simultaneously
   - Deforms mesh based on calculated displacements
   - Colors elements based on stress or displacement values
   - Creates interactive 3D visualization with colorbar

### Results Storage and Retrieval
1. `save_results()` → Saves results to file
   - Supports pickle, JSON, and HDF5 formats
   - Includes metadata about the analysis
2. `load_results()` → Loads results from file
   - Automatically detects file format
   - Reconstructs numpy arrays from serialized data

## 5. Configuration Options

### Material Properties
- `young_modulus`: Young's modulus in MPa (default: 2000.0 for typical PLA)
- `poisson_ratio`: Poisson's ratio (default: 0.3 for typical PLA)

### Boundary Conditions
- `displacement_percentage`: Percentage of model height for top displacement (default: 1.0)
- `custom_top_bc`: Custom function for top surface boundary conditions
- `custom_bottom_bc`: Custom function for bottom surface boundary conditions

### Visualization Options
- `visualization`: Whether to generate visualization (default: True)
- `result_type`: Type of result to visualize ('displacement', 'von_mises')
- `scale_factor`: Factor to scale displacements for visualization (default: 1.0)
- `show_undeformed`: Whether to show the original undeformed mesh (default: False)
- `original_opacity`: Opacity of the original mesh when shown (default: 0.3)

### Results Storage Options
- `save_results`: Whether to save results to a file (default: False)
- `save_path`: Path to save results (default: 'Results_volco/fea/results')
- `save_format`: Format to save results ('pickle', 'json', or 'hdf5') (default: 'pickle')
- `include_visualization`: Whether to include visualization in saved file (default: False)

## 6. Usage Patterns

### Basic Usage
```python
from volco import run_simulation
from app.postprocessing.fea import analyze_voxel_matrix

# Run VOLCO simulation
output = run_simulation(
    gcode_path='examples/gcode_example.gcode',
    printer_config_path='examples/printer_settings.json',
    sim_config_path='examples/simulation_settings.json'
)

# Get voxel matrix and voxel size
voxel_matrix = output.voxel_space.space
voxel_size = output._simulation.voxel_size

# Run FEA analysis
results = analyze_voxel_matrix(
    voxel_matrix=voxel_matrix,
    voxel_size=voxel_size,
    visualization=True,
    result_type='von_mises',
    scale_factor=10.0  # Exaggerate deformation for visualization
)

# Access results
print(f"Maximum displacement: {results['max_displacement']} mm")
print(f"Maximum von Mises stress: {results['max_von_mises']} MPa")

# Save visualization
from app.postprocessing.fea.viz import export_visualization
export_visualization(results['visualization'], "fea_results.html")
```

### Saving and Loading Results
```python
# Save results
results = analyze_voxel_matrix(
    voxel_matrix=voxel_matrix,
    voxel_size=voxel_size,
    save_results=True,
    save_path='Results_volco/fea/my_analysis',
    save_format='pickle'
)

# Load results
from app.postprocessing.fea import load_fea_results
loaded_results = load_fea_results('Results_volco/fea/my_analysis.pkl')

# Create visualization from loaded results
from app.postprocessing.fea.viz import visualize_fea, export_visualization
viz = visualize_fea(
    nodes=loaded_results['nodes'],
    elements=loaded_results['elements'],
    displacements=loaded_results['displacements'],
    von_mises=loaded_results['von_mises'],
    result_type='von_mises',
    scale_factor=1.0,
    show_undeformed=True  # Show both original and deformed meshes
)

# Export the visualization to an HTML file
export_visualization(viz, "visualization.html")
```

### Custom Material Properties
```python
# Define custom material properties for ABS
material_properties = {
    'young_modulus': 2300.0,  # MPa (typical for ABS)
    'poisson_ratio': 0.35     # Typical for ABS
}

results = analyze_voxel_matrix(
    voxel_matrix=voxel_matrix,
    voxel_size=voxel_size,
    material_properties=material_properties
)
```

### Custom Boundary Conditions
```python
# Define custom boundary conditions
boundary_conditions = {
    'displacement_percentage': 2.0  # 2% displacement instead of default 1%
}

results = analyze_voxel_matrix(
    voxel_matrix=voxel_matrix,
    voxel_size=voxel_size,
    boundary_conditions=boundary_conditions
)
```

## 7. Key Algorithms

### Mesh Generation
- **Voxel to Hexahedral Conversion**: Each material voxel is converted to a hexahedral element with 8 nodes
- **Node Sharing**: Nodes are shared between adjacent elements to ensure mesh continuity
- **Continuity Checking**: Connected component labeling is used to ensure the model is a single continuous body

### Linear Static FEA
- **Direct Stiffness Method**: Assembly of element stiffness matrices into global stiffness matrix
- **Gaussian Quadrature**: Numerical integration for element stiffness calculation
- **Shape Functions**: Trilinear shape functions for hexahedral elements
- **Sparse Matrix Solver**: Efficient solution of large sparse linear systems

### Stress and Strain Calculation
- **Strain-Displacement Relation**: B-matrix maps nodal displacements to strains
- **Stress-Strain Relation**: D-matrix (material matrix) maps strains to stresses
- **von Mises Stress**: Calculation of equivalent stress for failure prediction

## 8. Module Dependencies

- `app/postprocessing/fea/__init__.py` → `app/postprocessing/fea/core.py`
- `app/postprocessing/fea/core.py` → `app/postprocessing/fea/mesh.py`, `app/postprocessing/fea/solver.py`, `app/postprocessing/fea/boundary.py`, `app/postprocessing/fea/viz.py`, `app/postprocessing/fea/io.py`
- `app/postprocessing/fea/mesh.py` → `scipy.ndimage` (for connected component labeling)
- `app/postprocessing/fea/solver.py` → `scipy.sparse`, `scipy.sparse.linalg` (for sparse matrix operations)
- `app/postprocessing/fea/viz.py` → `plotly`
- `app/postprocessing/fea/io.py` → `pickle`, `json`, `h5py` (optional)

## 9. Common Modification Patterns

### Adding New Material Models
1. Modify `solver.py` to include new material behavior
2. Update the material matrix calculation in `calculate_element_stiffness()`
3. Add new material parameters to the `material_properties` dictionary

### Supporting Additional Boundary Conditions
1. Create new helper functions in `boundary.py`
2. Update `apply_default_boundary_conditions()` or create a new boundary condition application function
3. Add new parameters to the `boundary_conditions` dictionary

### Adding New Result Types
1. Update `calculate_stresses_and_strains()` in `solver.py` to compute additional results
2. Modify the `results` dictionary in `analyze_voxel_matrix()` to include the new results
3. Update visualization functions to support the new result type

### Extending Visualization Capabilities
1. Add new visualization features to the unified `visualize_fea()` function in `viz.py`
2. Add any necessary parameters to the visualization methods

## 10. Performance Considerations

- **Mesh Size**: The number of elements grows cubically with model resolution, affecting memory usage and computation time
- **Sparse Matrix Operations**: Efficient sparse matrix storage and solvers are used to handle large models
- **Visualization Memory Usage**: Rendering large models can be memory-intensive, especially with Plotly
- **Optimized Mesh Rendering**: The "volco mesh visualization method" significantly improves performance by only rendering visible faces
- **File Format Selection**: HDF5 is more efficient for large datasets compared to pickle or JSON
- **Continuity Checking**: Connected component labeling can be memory-intensive for large voxel matrices
- **Parallelization**: The current implementation is single-threaded; parallelization could improve performance for large models