# VOLCO Finite Element Analysis (FEA) Module

This module provides structural analysis capabilities for voxel models generated by VOLCO simulations. It enables you to analyze the mechanical behavior of 3D printed parts under load, visualize results, and save/load analysis data.

## Features

- Convert voxel matrices to finite element meshes
- Apply boundary conditions to the mesh
- Solve linear static structural problems
- Visualize displacements, stresses, and strains with optimized rendering
- Compare original and deformed meshes in a single visualization
- Save and load analysis results in various formats

## Simplified Import

For convenience, you can import all FEA functionality from a single module:

```python
from volco_fea import analyze_voxel_matrix, visualize_fea, Surface, export_visualization
```

## Basic Usage

```python
from volco import run_simulation
from volco_fea import analyze_voxel_matrix, Surface

# Run VOLCO simulation
output = run_simulation(
    gcode_path='examples/gcode_example.gcode',
    printer_config_path='examples/printer_settings.json',
    sim_config_path='examples/simulation_settings.json'
)

# Get the cropped voxel matrix from the simulation output
voxel_matrix = output.cropped_voxel_space
voxel_size = output._simulation.voxel_size

# Define boundary conditions using Simple Mode

# Calculate displacement as 1% of model height
model_height = voxel_matrix.shape[2] * voxel_size
displacement_magnitude = model_height * 0.01

boundary_conditions = {
    'constraints': {
        Surface.MINUS_Z: "fix",  # Fix bottom surface
        Surface.PLUS_Z: [None, None, -displacement_magnitude, None, None, None]  # Apply compression on top
    }
}

# Run FEA analysis
results = analyze_voxel_matrix(
    voxel_matrix=voxel_matrix,
    voxel_size=voxel_size,
    boundary_conditions=boundary_conditions
)

# Access results
print(f"Maximum displacement: {results['max_displacement']} mm")
print(f"Maximum von Mises stress: {results['max_von_mises']} MPa")

# If visualization was enabled
if 'visualization' in results:
    from volco_fea import export_visualization
    export_visualization(results['visualization'], "Results_volco/fea/von_mises.html")
```

## API Reference

### Main Functions

#### `analyze_voxel_matrix(voxel_matrix, voxel_size, **options)`

Perform finite element analysis on a voxel matrix.

**Parameters:**
- `voxel_matrix`: 3D numpy array representing the voxel model (1 = material, 0 = void)
- `voxel_size`: Size of each voxel in mm
- `material_properties`: Dictionary containing material properties (optional)
  - `young_modulus`: Young's modulus in MPa (default: 2000 for typical PLA)
  - `poisson_ratio`: Poisson's ratio (default: 0.3 for typical PLA)
- `boundary_conditions`: Dictionary specifying boundary conditions (required)
  - `constraints`: Dictionary mapping surface identifiers or custom functions to constraints
    - Simple Mode: `{Surface.MINUS_Z: "fix", Surface.PLUS_Z: [None, None, -0.1, None, None, None]}`
    - Expert Mode: `{"custom": custom_function}`
- `visualization`: Whether to generate visualization (default: True)
- `result_type`: Type of result to visualize ('displacement', 'von_mises')
- `scale_factor`: Factor to scale displacements for visualization (default: 1.0)
- `show_undeformed`: Whether to show the original undeformed mesh alongside the deformed mesh (default: False)
- `original_opacity`: Opacity of the original mesh when shown (default: 0.3)
- `save_results`: Whether to save results to a file (default: False)
- `save_path`: Path to save results (default: 'Results_volco/fea/results')
- `save_format`: Format to save results ('pickle', 'json', or 'hdf5') (default: 'pickle')
- `include_visualization`: Whether to include visualization in saved file (default: False)

**Returns:**
Dictionary containing analysis results:
- `nodes`: Node coordinates
- `elements`: Element connectivity
- `displacements`: Nodal displacements
- `stresses`: Element stresses
- `strains`: Element strains
- `von_mises`: von Mises stress for each element
- `max_displacement`: Maximum displacement magnitude
- `max_von_mises`: Maximum von Mises stress
- `visualization`: Visualization object (if visualization=True)
- `saved_file`: Path to saved results file (if save_results=True)

#### `load_fea_results(file_path)`

Load FEA results from a file.

**Parameters:**
- `file_path`: Path to the file containing saved FEA results

**Returns:**
Dictionary containing the loaded FEA results

## Examples

### Basic Analysis

```python
results = analyze_voxel_matrix(
    voxel_matrix=voxel_matrix,
    voxel_size=voxel_size,
    visualization=True,
    result_type='von_mises',
    scale_factor=10.0  # Exaggerate deformation for visualization
)
```

### Custom Material Properties

```python
# Define material properties for ABS
material_properties = {
    'young_modulus': 2300.0,  # MPa (typical for ABS)
    'poisson_ratio': 0.35     # Typical for ABS
}

results = analyze_voxel_matrix(
    voxel_matrix=voxel_matrix,
    voxel_size=voxel_size,
    material_properties=material_properties
)
```

### Enhanced Boundary Condition System

The FEA module provides an enhanced boundary condition system with two modes:

#### Simple Mode

Simple Mode uses Surface enumerations and simple constraint specifications, making it easy for non-experts to apply boundary conditions.

```python
from volco_fea import Surface

# Get model dimensions
model_height = np.max(voxel_matrix.shape) * voxel_size
displacement_magnitude = model_height * 0.01  # 1% of model height

# Define boundary conditions using Simple Mode
boundary_conditions = {
    'constraints': {
        Surface.MINUS_Z: "fix",  # Fix bottom surface
        Surface.PLUS_Z: [None, None, -displacement_magnitude, None, None, None]  # Apply compression on top
    }
}

results = analyze_voxel_matrix(
    voxel_matrix=voxel_matrix,
    voxel_size=voxel_size,
    boundary_conditions=boundary_conditions
)
```

You can use the "fix" keyword to constrain all degrees of freedom, or specify a vector [ux, uy, uz, rx, ry, rz] where None means unconstrained.

Example for tension in X direction:
```python
# Calculate displacement as 1% of model width
model_width = np.max(voxel_matrix.shape) * voxel_size
displacement_magnitude = model_width * 0.01

boundary_conditions = {
    'constraints': {
        Surface.MINUS_X: "fix",  # Fix -X surface
        Surface.PLUS_X: [displacement_magnitude, None, None, None, None, None]  # Apply tension on +X
    }
}
```

Available Surface enumerations:
- `Surface.PLUS_X`: +x surface
- `Surface.MINUS_X`: -x surface
- `Surface.PLUS_Y`: +y surface
- `Surface.MINUS_Y`: -y surface
- `Surface.PLUS_Z`: +z surface
- `Surface.MINUS_Z`: -z surface

#### Expert Mode

Expert Mode provides direct access to node data structures with functional utilities, giving FEA experts full control over boundary conditions.

```python
# Define custom boundary conditions using expert mode with list comprehensions
def custom_constraint_function(nodes, elements):
    # Get model dimensions directly
    x_coords = nodes[:, 0]
    y_coords = nodes[:, 1]
    z_coords = nodes[:, 2]
    
    # Calculate model height
    model_height = np.max(z_coords) - np.min(z_coords)
    
    # Calculate displacement as 2% of model height
    displacement_magnitude = model_height * 0.02
    
    # Create constraints dictionary using list comprehension
    return {
        # Fix nodes in bottom 10% using list comprehension
        i: [0, 0, 0, 0, 0, 0] for i in range(len(nodes))
        if nodes[i, 2] < np.min(z_coords) + 0.1 * model_height
    } | {
        # Apply displacement to nodes in top 5% using another list comprehension
        i: [None, None, -displacement_magnitude, None, None, None] for i in range(len(nodes))
        if nodes[i, 2] > np.max(z_coords) - 0.05 * model_height
    }

# Define boundary conditions
boundary_conditions = {
    'constraints': {
        "custom": custom_constraint_function
    }
}
```

#### Functional Utilities for Expert Mode

The module provides several utility functions to help with node selection:

```python
from volco_fea import select_nodes_by_predicate, select_nodes_in_box

def custom_constraint_function(nodes, elements):
    # Get model dimensions
    x_min, y_min, z_min = np.min(nodes, axis=0)
    x_max, y_max, z_max = np.max(nodes, axis=0)
    
    # Select nodes in the bottom box (10% of height)
    bottom_nodes = select_nodes_in_box(
        nodes,
        [x_min, y_min, z_min],
        [x_max, y_max, z_min + 0.1 * (z_max - z_min)]
    )
    
    # Select nodes on a diagonal plane where x â‰ˆ y
    diagonal_nodes = select_nodes_by_predicate(
        nodes,
        lambda node: abs(node[0] - node[1]) < 0.1 * (x_max - x_min)
    )
    
    # Create constraints dictionary
    constraints = {}
    
    # Fix bottom nodes
    for node_idx in bottom_nodes:
        constraints[node_idx] = [0, 0, 0, 0, 0, 0]
    
    # Apply displacement to diagonal nodes that are in the top half
    for node_idx in diagonal_nodes:
        if nodes[node_idx, 2] > (z_min + z_max) / 2:
            # Calculate displacement as 1.5% of model height
            displacement_magnitude = (z_max - z_min) * 0.015
            constraints[node_idx] = [None, None, -displacement_magnitude, None, None, None]
    
    return constraints
}
```

Available utility functions:
- `select_nodes_by_predicate(nodes, predicate)`: Select nodes that satisfy a given predicate function
- `select_nodes_in_box(nodes, min_coords, max_coords)`: Select nodes within a bounding box
- `select_nodes_on_plane(nodes, point, normal, tolerance)`: Select nodes on a plane defined by a point and normal vector
- `select_nodes_by_position(nodes, x_range, y_range, z_range)`: Select nodes within specified coordinate ranges


### Saving Results

```python
results = analyze_voxel_matrix(
    voxel_matrix=voxel_matrix,
    voxel_size=voxel_size,
    save_results=True,
    save_path='Results_volco/fea/my_analysis',
    save_format='pickle'
)
```

### Loading Results

```python
from volco_fea import load_fea_results, visualize_fea, export_visualization

# Load results
loaded_results = load_fea_results('Results_volco/fea/my_analysis.pkl')

# Create visualization from loaded results
viz = visualize_fea(
    nodes=loaded_results['nodes'],
    elements=loaded_results['elements'],
    displacements=loaded_results['displacements'],
    von_mises=loaded_results['von_mises'],
    result_type='von_mises',
    scale_factor=1.0,
    show_undeformed=True  # Show both original and deformed meshes
)

# Export the visualization to an HTML file
export_visualization(viz, "Results_volco/fea/loaded_von_mises_with_undeformed.html")
```

## Example Files

For complete examples, see:
- [examples/fea_example.py](../../../examples/fea_example.py) - Basic example of FEA analysis
- [examples/fea_save_results.py](../../../examples/fea_save_results.py) - Example of saving FEA results
- [examples/fea_load_results.py](../../../examples/fea_load_results.py) - Example of loading and visualizing FEA results
- [examples/fea_boundary_conditions_example.py](../../../examples/fea_boundary_conditions_example.py) - Examples of using the enhanced boundary condition system

## Module Structure

- `__init__.py`: Module entry point
- `core.py`: Main analysis functionality
- `mesh.py`: Mesh generation from voxel matrices
- `boundary.py`: Boundary condition application
- `solver.py`: Linear static FEA solver
- `viz.py`: Visualization of results using optimized mesh rendering
- `io.py`: Input/output functionality for saving/loading results

For a comprehensive overview of the module structure and functionality, see [llm_ref_fea.md](../../../llm_ref_fea.md).

## Visualization Features

The FEA module includes advanced visualization capabilities through the `visualize_fea()` function:

### Optimized Mesh Visualization

The visualization uses the "volco mesh visualization method" which:
- Only renders visible faces of the mesh (faces that are exposed to the outside)
- Creates a 3D grid representation of the voxel structure to determine visibility
- Triangulates quadrilateral faces for better rendering
- Significantly improves performance for large models by reducing the number of rendered faces

### Unified Visualization Function

The `visualize_fea()` function provides a unified interface for all visualization needs:

```python
from volco_fea import visualize_fea, export_visualization

# Create visualization
viz = visualize_fea(
    nodes=results['nodes'],
    elements=results['elements'],
    displacements=results['displacements'],
    von_mises=results['von_mises'],
    result_type='von_mises',  # or 'displacement'
    scale_factor=10.0,        # Exaggerate deformation
    show_undeformed=True,     # Show original mesh alongside deformed
    original_opacity=0.3      # Transparency of original mesh
)

# Export to HTML file
export_visualization(viz, "Results_volco/fea/von_mises_with_undeformed.html")
```

### Visualization Options

- **Result Types**: Choose between 'displacement' or 'von_mises' stress visualization
- **Dual Mesh View**: Show both original and deformed meshes in a single visualization
- **Scale Factor**: Control the exaggeration of displacements for better visibility
- **Original Mesh Opacity**: Adjust transparency of the original mesh when shown

### Example: Visualizing Both Original and Deformed Meshes

```python
# Visualize both original and deformed meshes with von Mises stress
viz = visualize_fea(
    nodes=results['nodes'],
    elements=results['elements'],
    displacements=results['displacements'],
    von_mises=results['von_mises'],
    result_type='von_mises',
    scale_factor=5.0,
    show_undeformed=True,
    original_opacity=0.2  # More transparent original mesh
)

# Export to HTML file
export_visualization(viz, "Results_volco/fea/von_mises_with_undeformed.html")
```